@page "/sim/{SimId}"

@using SkyNet.Simulator.Contracts
@using SkyNet.Simulator.Dashboard.Components
@using SkyNet.Simulator.Dashboard.Services
@implements IAsyncDisposable

@inject SimApiClient Api
@inject SimHubClient Hub
@inject DaemonClientOptions Options
@inject SimViewCache ViewCache

<PageTitle>Simulation</PageTitle>

<h1>Simulation</h1>
<p>
	<b>SimId:</b> <code>@SimId</code>
	<br />
	<b>Daemon:</b> <code>@Options.BaseUri</code>
</p>

<div style="display:flex; gap: 0.5rem; flex-wrap: wrap; align-items: center;">
	<button @onclick="Pause" disabled="@(_status?.IsPaused ?? false)">Pause</button>
	<button @onclick="Resume" disabled="@(!(_status?.IsPaused ?? true))">@(_status?.Tick == 0 ? "Start" : "Resume")</button>
	<button @onclick="StepOnce" disabled="@(!(_status?.IsPaused ?? false))">Step</button>
	<span style="margin-left: 0.75rem;">Connection: <b>@(Hub.IsConnected ? "Connected" : "Disconnected")</b></span>
</div>

@if (!string.IsNullOrWhiteSpace(_error))
{
	<p style="color: darkred;"><b>Error:</b> @_error</p>
}

@if (_uiSnapshot is null)
{
	<p>Waiting for telemetry...</p>
}
else
{
	<p>
		<b>Tick</b> @_uiSnapshot.Tick | <b>Sim Time</b> @_uiSnapshot.TimeSeconds.ToString("0.000")s
		@if (_status is not null)
		{
			<span> | <b>Paused</b> @_status.IsPaused</span>
		}
	</p>

	<h2>Key Signals</h2>
	<div style="display:flex; gap: 1rem; flex-wrap: wrap;">
		@foreach (var key in _keySignals)
		{
			var value = _uiSnapshot.Signals.TryGetValue(key, out var v) ? v : double.NaN;
			<div style="border: 1px solid #ccc; padding: 0.75rem; min-width: 200px;">
				<div style="font-size: 0.9rem; opacity: 0.8;">@key</div>
				<div style="font-size: 1.5rem;"><b>@value.ToString("0.###")</b></div>
			</div>
		}
	</div>

	<h2>Trends</h2>
	<div style="display:flex; gap: 1rem; flex-wrap: wrap;">
		<LineChart Title="@_chart1Title" SubTitle="@_chart1Unit" Stroke="#d62728" Points="@_pressureSeries" YFormat="@_chart1Format" />
		<LineChart Title="@_chart2Title" SubTitle="@_chart2Unit" Stroke="#1f77b4" Points="@_positionSeries" YFormat="@_chart2Format" />
		<LineChart Title="@_chart3Title" SubTitle="@_chart3Unit" Stroke="#2ca02c" Points="@_flowSeries" YFormat="@_chart3Format" />
	</div>
}

<h2>Parameters</h2>
@if (_parameterDefinitions is null)
{
	<p>Loading parameter definitions...</p>
}
else
{
	<table class="table">
		<thead>
			<tr>
				<th>Name</th>
				<th>Value</th>
				<th>Min</th>
				<th>Max</th>
				<th>Set</th>
				<th>Description</th>
			</tr>
		</thead>
		<tbody>
			@foreach (var def in _parameterDefinitions)
			{
				var snap = _tableSnapshot ?? _uiSnapshot;
				double current;
				if (snap is not null && snap.Parameters.TryGetValue(def.Name, out var vSnap))
				{
					current = vSnap;
				}
				else if (_lastParameterValues.TryGetValue(def.Name, out var vPoll))
				{
					current = vPoll;
				}
				else
				{
					current = double.NaN;
				}
				_parameterEdits.TryGetValue(def.Name, out var edit);

				<tr>
					<td><code>@def.Name</code></td>
					<td>@current.ToString("0.###")</td>
					<td>@(def.MinValue?.ToString("0.###") ?? "-")</td>
					<td>@(def.MaxValue?.ToString("0.###") ?? "-")</td>
					<td style="white-space: nowrap;">
						<input type="number" step="any" style="width: 120px;" value="@edit" @onchange="e => OnEditChanged(def.Name, e)" />
						<button style="margin-left: 0.25rem;" @onclick="() => ApplyParameter(def.Name)">Set</button>
					</td>
					<td>@def.Description</td>
				</tr>
			}
		</tbody>
	</table>
}

<h2>All Signals</h2>
@if (_sortedSignals.Length == 0)
{
	<p>No signals yet.</p>
}
else
{
	<table class="table">
		<thead>
			<tr>
				<th>Name</th>
				<th>Value</th>
			</tr>
		</thead>
		<tbody>
			@foreach (var kvp in _sortedSignals)
			{
				<tr>
					<td><code>@kvp.Key</code></td>
					<td>@kvp.Value.ToString("0.###")</td>
				</tr>
			}
		</tbody>
	</table>
}

@code {
	[Parameter] public string SimId { get; set; } = string.Empty;

	private readonly object _seriesLock = new();
	private const int MaxPoints = 600; // ~30s at ~20Hz telemetry

	private string[] _keySignals =
	[
		"DownstreamPressurePsi",
		"DownstreamPressureSensorPsi",
		"ValveFlowGpm",
		"ActuatorPosition",
		"ActuatorVelocity",
	];

	private string _chart1Title = "Downstream Pressure";
	private string? _chart1Unit = "psi";
	private string _chart1SignalKey = "DownstreamPressurePsi";
	private string _chart1Format = "0.0";

	private string _chart2Title = "Actuator Position";
	private string? _chart2Unit = "pos";
	private string _chart2SignalKey = "ActuatorPosition";
	private string _chart2Format = "0.000";

	private string _chart3Title = "Valve Flow";
	private string? _chart3Unit = "gpm";
	private string _chart3SignalKey = "ValveFlowGpm";
	private string _chart3Format = "0.0";

	private LineChart.Point[] _pressureSeries = Array.Empty<LineChart.Point>();
	private LineChart.Point[] _positionSeries = Array.Empty<LineChart.Point>();
	private LineChart.Point[] _flowSeries = Array.Empty<LineChart.Point>();
	private readonly List<LineChart.Point> _pressurePoints = new(MaxPoints);
	private readonly List<LineChart.Point> _positionPoints = new(MaxPoints);
	private readonly List<LineChart.Point> _flowPoints = new(MaxPoints);

	private TelemetrySnapshot? _latestSnapshot;
	private long _latestSnapshotSeq;
	private TelemetrySnapshot? _uiSnapshot;
	private TelemetrySnapshot? _tableSnapshot;
	private DateTimeOffset _lastSnapshotAt = DateTimeOffset.MinValue;
	private long _lastUiTick = -1;
	private long _lastRenderedSnapshotSeq = -1;
	private DateTimeOffset _lastTableRefreshAt = DateTimeOffset.MinValue;
	private KeyValuePair<string, double>[] _sortedSignals = Array.Empty<KeyValuePair<string, double>>();
	private SimStatus? _status;
	private ParameterDefinitionDto[]? _parameterDefinitions;
	private readonly Dictionary<string, double> _parameterEdits = new(StringComparer.OrdinalIgnoreCase);
	private readonly Dictionary<string, double> _lastParameterValues = new(StringComparer.OrdinalIgnoreCase);
	private readonly Dictionary<string, double> _lastSignalValues = new(StringComparer.OrdinalIgnoreCase);
	private string? _error;
	private CancellationTokenSource? _cts;
	private Task? _pollTask;
	private Task? _renderTask;
	private string? _currentSimId;

	protected override Task OnInitializedAsync()
	{
		_cts = new CancellationTokenSource();
		Hub.SnapshotReceived += OnSnapshot;
		_renderTask = RenderTelemetryLoopAsync(_cts.Token);
		_pollTask = PollStatusLoopAsync(_cts.Token);
		return Task.CompletedTask;
	}

	protected override async Task OnParametersSetAsync()
	{
		if (_cts is null)
		{
			return;
		}

		if (string.Equals(_currentSimId, SimId, StringComparison.OrdinalIgnoreCase))
		{
			return;
		}

		_currentSimId = SimId;
		_error = null;
		_uiSnapshot = null;
		_tableSnapshot = null;
		_sortedSignals = Array.Empty<KeyValuePair<string, double>>();
		Volatile.Write(ref _latestSnapshot, null);
		Volatile.Write(ref _latestSnapshotSeq, 0);
		_lastSnapshotAt = DateTimeOffset.MinValue;
		_lastUiTick = -1;
		_lastRenderedSnapshotSeq = -1;

		ConfigureViewForSim(SimId);

		// If we have cached UI state, show it immediately (useful when sim is paused).
		if (ViewCache.TryGet(SimId, out var state))
		{
			var snap = state.Snapshot();
			if (snap.ParameterEdits.Count > 0)
			{
				_parameterEdits.Clear();
				foreach (var kvp in snap.ParameterEdits)
				{
					_parameterEdits[kvp.Key] = kvp.Value;
				}
			}
			if (snap.LatestSnapshot is not null)
			{
				Volatile.Write(ref _latestSnapshot, snap.LatestSnapshot);
				Interlocked.Increment(ref _latestSnapshotSeq);
				_uiSnapshot = snap.LatestSnapshot;
				_tableSnapshot = snap.LatestSnapshot;
				_lastUiTick = snap.LatestSnapshot.Tick;
				_pressureSeries = snap.PressureSeries;
				_positionSeries = snap.PositionSeries;
				_flowSeries = snap.FlowSeries;
				_sortedSignals = snap.SortedSignals;
				await InvokeAsync(StateHasChanged);
			}
		}
		else if (Hub.TryGetLatestSnapshot(SimId, out var cachedHubSnapshot))
		{
			Volatile.Write(ref _latestSnapshot, cachedHubSnapshot);
			Interlocked.Increment(ref _latestSnapshotSeq);
			_uiSnapshot = cachedHubSnapshot;
			_tableSnapshot = cachedHubSnapshot;
			_lastUiTick = cachedHubSnapshot.Tick;
			await InvokeAsync(StateHasChanged);
		}

		// Reset UI state when switching sims.
		// Keep cached visuals, but reset local series buffers for fresh accumulation.
		_pressurePoints.Clear();
		_positionPoints.Clear();
		_flowPoints.Clear();

		try
		{
			_parameterDefinitions = await Api.GetParameterDefinitionsAsync(SimId, _cts.Token);
			var values = await Api.GetParameterValuesAsync(SimId, _cts.Token);
			var signals = await Api.GetSignalsAsync(SimId, _cts.Token);

			_lastParameterValues.Clear();
			foreach (var kvp in values)
			{
				_lastParameterValues[kvp.Key] = kvp.Value;
			}

			_lastSignalValues.Clear();
			foreach (var kvp in signals)
			{
				_lastSignalValues[kvp.Key] = kvp.Value;
			}

			_sortedSignals = signals
				.OrderBy(k => k.Key, StringComparer.OrdinalIgnoreCase)
				.ToArray();

			// If SignalR is down or the sim is paused, still render a snapshot based on polled data.
			try { _status = await Api.GetStatusAsync(SimId, _cts.Token); } catch { /* ignore */ }
			var polledSnapshot = new TelemetrySnapshot(
				SimId: SimId,
				SchemaVersion: 0,
				Tick: _status?.Tick ?? 0,
				TimeSeconds: _status?.TimeSeconds ?? 0,
				Parameters: values,
				Signals: signals);
			Volatile.Write(ref _latestSnapshot, polledSnapshot);
			Interlocked.Increment(ref _latestSnapshotSeq);
			_uiSnapshot = polledSnapshot;
			_tableSnapshot = polledSnapshot;
			_lastTableRefreshAt = DateTimeOffset.UtcNow;

			// Merge server values into cached edits (but keep any user-entered drafts).
			var viewState = ViewCache.GetOrCreate(SimId);
			viewState.MergeParameterEditsFromValues(values);
			if (_parameterDefinitions is not null)
			{
				viewState.RemoveUnknownParameterEdits(_parameterDefinitions.Select(d => d.Name).ToArray());
			}

			_parameterEdits.Clear();
			foreach (var kvp in viewState.ParameterEditsSnapshot())
			{
				_parameterEdits[kvp.Key] = kvp.Value;
			}
		}
		catch (Exception ex)
		{
			_error = ex.Message;
		}

		try
		{
			await Hub.JoinSimulationAsync(SimId, _cts.Token);
		}
		catch (Exception ex)
		{
			_error = ex.Message;
		}
	}

	private void OnSnapshot(TelemetrySnapshot snapshot)
	{
		if (!string.Equals(snapshot.SimId, SimId, StringComparison.OrdinalIgnoreCase))
		{
			return;
		}
		Volatile.Write(ref _latestSnapshot, snapshot);
		Interlocked.Increment(ref _latestSnapshotSeq);
		_lastSnapshotAt = DateTimeOffset.UtcNow;
		ViewCache.GetOrCreate(snapshot.SimId).SetSnapshot(snapshot);
	}

	private async Task RenderTelemetryLoopAsync(CancellationToken cancellationToken)
	{
		using var timer = new PeriodicTimer(TimeSpan.FromMilliseconds(100)); // 10Hz UI refresh
		try
		{
			while (await timer.WaitForNextTickAsync(cancellationToken))
			{
				var snapshot = Volatile.Read(ref _latestSnapshot);
				var seq = Volatile.Read(ref _latestSnapshotSeq);
				if (snapshot is null)
				{
					continue;
				}

				if (seq == _lastRenderedSnapshotSeq)
				{
					continue;
				}

				_lastRenderedSnapshotSeq = seq;

				_lastUiTick = snapshot.Tick;
				_uiSnapshot = snapshot;

				lock (_seriesLock)
				{
					var t = snapshot.TimeSeconds;
					Append(_pressurePoints, t, snapshot.Signals.GetValueOrDefault(_chart1SignalKey));
					Append(_positionPoints, t, snapshot.Signals.GetValueOrDefault(_chart2SignalKey));
					Append(_flowPoints, t, snapshot.Signals.GetValueOrDefault(_chart3SignalKey));

					_pressureSeries = _pressurePoints.ToArray();
					_positionSeries = _positionPoints.ToArray();
					_flowSeries = _flowPoints.ToArray();
				}

				var now = DateTimeOffset.UtcNow;
				if (now - _lastTableRefreshAt >= TimeSpan.FromMilliseconds(500))
				{
					_lastTableRefreshAt = now;
					_tableSnapshot = snapshot;
					_sortedSignals = snapshot.Signals
						.OrderBy(k => k.Key, StringComparer.OrdinalIgnoreCase)
						.ToArray();
				}

				// Persist last-rendered UI state so navigation back can instantly rehydrate.
				ViewCache.GetOrCreate(snapshot.SimId).SetRenderedState(
					snapshot,
					_pressureSeries,
					_positionSeries,
					_flowSeries,
					_sortedSignals);

				await InvokeAsync(StateHasChanged);
			}
		}
		catch (OperationCanceledException)
		{
			// normal shutdown
		}
	}

	private static void Append(List<LineChart.Point> series, double timeSeconds, double value)
	{
		series.Add(new LineChart.Point(timeSeconds, value));
		if (series.Count <= MaxPoints)
		{
			return;
		}

		var remove = series.Count - MaxPoints;
		series.RemoveRange(0, remove);
	}

	private async Task PollStatusLoopAsync(CancellationToken cancellationToken)
	{
		while (!cancellationToken.IsCancellationRequested)
		{
			try
			{
				var simId = _currentSimId;
				if (!string.IsNullOrWhiteSpace(simId))
				{
					_status = await Api.GetStatusAsync(simId, cancellationToken);

					// Fallback: if live snapshots aren't arriving, poll so the page stays live.
					if ((DateTimeOffset.UtcNow - _lastSnapshotAt) > TimeSpan.FromSeconds(1))
					{
						var parameters = await Api.GetParameterValuesAsync(simId, cancellationToken);
						var signals = await Api.GetSignalsAsync(simId, cancellationToken);

						_lastParameterValues.Clear();
						foreach (var kvp in parameters)
						{
							_lastParameterValues[kvp.Key] = kvp.Value;
						}

						_lastSignalValues.Clear();
						foreach (var kvp in signals)
						{
							_lastSignalValues[kvp.Key] = kvp.Value;
						}

						_sortedSignals = signals
							.OrderBy(k => k.Key, StringComparer.OrdinalIgnoreCase)
							.ToArray();

						var polledSnapshot = new TelemetrySnapshot(
							SimId: simId,
							SchemaVersion: 0,
							Tick: _status.Tick,
							TimeSeconds: _status.TimeSeconds,
							Parameters: parameters,
							Signals: signals);

						Volatile.Write(ref _latestSnapshot, polledSnapshot);
						Interlocked.Increment(ref _latestSnapshotSeq);
						_uiSnapshot = polledSnapshot;
						_tableSnapshot = polledSnapshot;
						_lastSnapshotAt = DateTimeOffset.UtcNow;
					}
				}
				await InvokeAsync(StateHasChanged);
			}
			catch
			{
				// ignore transient errors while starting up/reconnecting
			}

			await Task.Delay(500, cancellationToken);
		}
	}

	private void ConfigureViewForSim(string simId)
	{
		if (string.Equals(simId, "tank-transfer", StringComparison.OrdinalIgnoreCase))
		{
			_keySignals =
			[
				"BlowlinePressurePsi",
				"AirlockSpeedHz",
				"TransferRateLbPerSec",
				"SourceTankWeightLb",
				"DestinationTankWeightLb",
				"BlowerMotorPercentFla",
				"IsStarved",
				"IsFull",
			];

			_chart1Title = "Blowline Pressure";
			_chart1Unit = "psi";
			_chart1SignalKey = "BlowlinePressurePsi";
			_chart1Format = "0.0";

			_chart2Title = "Transfer Rate";
			_chart2Unit = "lb/s";
			_chart2SignalKey = "TransferRateLbPerSec";
			_chart2Format = "0.0";

			_chart3Title = "Blower Motor";
			_chart3Unit = "% FLA";
			_chart3SignalKey = "BlowerMotorPercentFla";
			_chart3Format = "0.0";
		}
		else
		{
			_keySignals =
			[
				"DownstreamPressurePsi",
				"DownstreamPressureSensorPsi",
				"ValveFlowGpm",
				"ActuatorPosition",
				"ActuatorVelocity",
			];

			_chart1Title = "Downstream Pressure";
			_chart1Unit = "psi";
			_chart1SignalKey = "DownstreamPressurePsi";
			_chart1Format = "0.0";

			_chart2Title = "Actuator Position";
			_chart2Unit = "pos";
			_chart2SignalKey = "ActuatorPosition";
			_chart2Format = "0.000";

			_chart3Title = "Valve Flow";
			_chart3Unit = "gpm";
			_chart3SignalKey = "ValveFlowGpm";
			_chart3Format = "0.0";
		}
	}

	private async Task Pause()
	{
		_error = null;
		try { await Api.PauseAsync(_currentSimId ?? SimId, _cts?.Token ?? default); } catch (Exception ex) { _error = ex.Message; }
	}

	private async Task Resume()
	{
		_error = null;
		try { await Api.ResumeAsync(_currentSimId ?? SimId, _cts?.Token ?? default); } catch (Exception ex) { _error = ex.Message; }
	}

	private async Task StepOnce()
	{
		_error = null;
		try { await Api.StepAsync(_currentSimId ?? SimId, 1, _cts?.Token ?? default); } catch (Exception ex) { _error = ex.Message; }
	}

	private void OnEditChanged(string name, ChangeEventArgs e)
	{
		if (e.Value is null)
		{
			return;
		}

		if (double.TryParse(e.Value.ToString(), out var parsed))
		{
			_parameterEdits[name] = parsed;
			ViewCache.GetOrCreate(_currentSimId ?? SimId).SetParameterEdit(name, parsed);
		}
	}

	private async Task ApplyParameter(string name)
	{
		_error = null;
		try
		{
			if (_parameterEdits.TryGetValue(name, out var v))
			{
				await Api.SetParameterAsync(_currentSimId ?? SimId, name, v, _cts?.Token ?? default);
			}
		}
		catch (Exception ex)
		{
			_error = ex.Message;
		}
	}

	public async ValueTask DisposeAsync()
	{
		Hub.SnapshotReceived -= OnSnapshot;
		try { await Hub.LeaveCurrentSimulationAsync().ConfigureAwait(false); } catch { /* ignore */ }
		var cts = Interlocked.Exchange(ref _cts, null);
		if (cts is not null)
		{
			try { cts.Cancel(); } catch { /* ignore */ }
			cts.Dispose();
		}
		if (_renderTask is not null)
		{
			try { await _renderTask.ConfigureAwait(false); } catch { /* ignore */ }
		}
		if (_pollTask is not null)
		{
			try { await _pollTask.ConfigureAwait(false); } catch { /* ignore */ }
		}
	}
}
