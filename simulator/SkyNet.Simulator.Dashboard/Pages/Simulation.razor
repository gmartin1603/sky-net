@page "/sim/{SimId}"

@using SkyNet.Simulator.Contracts
@using SkyNet.Simulator.Dashboard.Components
@using SkyNet.Simulator.Dashboard.Services
@implements IAsyncDisposable

@inject SimApiClient Api
@inject SimHubClient Hub
@inject DaemonClientOptions Options
@inject SimViewCache ViewCache

<PageTitle>Simulation</PageTitle>

<h1>Simulation</h1>
<p>
	<b>SimId:</b> <code>@SimId</code>
	<br />
	<b>Daemon:</b> <code>@Options.BaseUri</code>
</p>

<div style="display:flex; gap: 0.5rem; flex-wrap: wrap; align-items: center;">
	<button @onclick="Pause" disabled="@(_status?.IsPaused ?? false)">Pause</button>
	<button @onclick="Resume" disabled="@(!(_status?.IsPaused ?? true))">@(_status?.Tick == 0 ? "Start" : "Resume")</button>
	<button @onclick="StepOnce" disabled="@(!(_status?.IsPaused ?? false))">Step</button>
	<span style="margin-left: 0.75rem;">Connection: <b>@(Hub.IsConnected ? "Connected" : "Disconnected")</b></span>
</div>

@if (!string.IsNullOrWhiteSpace(_error))
{
	<p style="color: darkred;"><b>Error:</b> @_error</p>
}

@if (_uiSnapshot is null)
{
	<p>Waiting for telemetry...</p>
}
else
{
	<p>
		<b>Tick</b> @_uiSnapshot.Tick | <b>Sim Time</b> @_uiSnapshot.TimeSeconds.ToString("0.000")s
		@if (_status is not null)
		{
			<span> | <b>Paused</b> @_status.IsPaused</span>
		}
	</p>

	<h2>Key Signals</h2>
	<div style="display:flex; gap: 1rem; flex-wrap: wrap;">
		@foreach (var key in _keySignals)
		{
			var value = _uiSnapshot.Signals.TryGetValue(key, out var v) ? v : double.NaN;
			<div style="border: 1px solid #ccc; padding: 0.75rem; min-width: 200px;">
				<div style="font-size: 0.9rem; opacity: 0.8;">@key</div>
				<div style="font-size: 1.5rem;"><b>@value.ToString("0.###")</b></div>
			</div>
		}
	</div>

	<h2>Trends</h2>
	<div style="display:flex; gap: 1rem; flex-wrap: wrap;">
		<LineChart Title="Downstream Pressure" SubTitle="psi" Stroke="#d62728" Points="@_pressureSeries" YFormat="0.0" />
		<LineChart Title="Actuator Position" SubTitle="pos" Stroke="#1f77b4" Points="@_positionSeries" YFormat="0.000" />
		<LineChart Title="Valve Flow" SubTitle="gpm" Stroke="#2ca02c" Points="@_flowSeries" YFormat="0.0" />
	</div>

	<h2>Parameters</h2>
	@if (_parameterDefinitions is null)
	{
		<p>Loading parameter definitions...</p>
	}
	else
	{
		<table class="table">
			<thead>
				<tr>
					<th>Name</th>
					<th>Value</th>
					<th>Min</th>
					<th>Max</th>
					<th>Set</th>
					<th>Description</th>
				</tr>
			</thead>
			<tbody>
				@foreach (var def in _parameterDefinitions)
				{
					var snap = _tableSnapshot ?? _uiSnapshot;
					var current = snap.Parameters.TryGetValue(def.Name, out var v) ? v : double.NaN;
					_parameterEdits.TryGetValue(def.Name, out var edit);

					<tr>
						<td><code>@def.Name</code></td>
						<td>@current.ToString("0.###")</td>
						<td>@(def.MinValue?.ToString("0.###") ?? "-")</td>
						<td>@(def.MaxValue?.ToString("0.###") ?? "-")</td>
						<td style="white-space: nowrap;">
							<input type="number" step="any" style="width: 120px;" value="@edit" @onchange="e => OnEditChanged(def.Name, e)" />
							<button style="margin-left: 0.25rem;" @onclick="() => ApplyParameter(def.Name)">Set</button>
						</td>
						<td>@def.Description</td>
					</tr>
				}
			</tbody>
		</table>
	}

	<h2>All Signals</h2>
	<table class="table">
		<thead>
			<tr>
				<th>Name</th>
				<th>Value</th>
			</tr>
		</thead>
		<tbody>
			@foreach (var kvp in _sortedSignals)
			{
				<tr>
					<td><code>@kvp.Key</code></td>
					<td>@kvp.Value.ToString("0.###")</td>
				</tr>
			}
		</tbody>
	</table>
}

@code {
	[Parameter] public string SimId { get; set; } = string.Empty;

	private readonly object _seriesLock = new();
	private const int MaxPoints = 600; // ~30s at ~20Hz telemetry

	private readonly string[] _keySignals =
	[
		"DownstreamPressurePsi",
		"DownstreamPressureSensorPsi",
		"ValveFlowGpm",
		"ActuatorPosition",
		"ActuatorVelocity",
	];

	private LineChart.Point[] _pressureSeries = Array.Empty<LineChart.Point>();
	private LineChart.Point[] _positionSeries = Array.Empty<LineChart.Point>();
	private LineChart.Point[] _flowSeries = Array.Empty<LineChart.Point>();
	private readonly List<LineChart.Point> _pressurePoints = new(MaxPoints);
	private readonly List<LineChart.Point> _positionPoints = new(MaxPoints);
	private readonly List<LineChart.Point> _flowPoints = new(MaxPoints);

	private TelemetrySnapshot? _latestSnapshot;
	private TelemetrySnapshot? _uiSnapshot;
	private TelemetrySnapshot? _tableSnapshot;
	private long _lastUiTick = -1;
	private DateTimeOffset _lastTableRefreshAt = DateTimeOffset.MinValue;
	private KeyValuePair<string, double>[] _sortedSignals = Array.Empty<KeyValuePair<string, double>>();
	private SimStatus? _status;
	private ParameterDefinitionDto[]? _parameterDefinitions;
	private readonly Dictionary<string, double> _parameterEdits = new(StringComparer.OrdinalIgnoreCase);
	private string? _error;
	private CancellationTokenSource? _cts;
	private Task? _pollTask;
	private Task? _renderTask;
	private string? _currentSimId;

	protected override Task OnInitializedAsync()
	{
		_cts = new CancellationTokenSource();
		Hub.SnapshotReceived += OnSnapshot;
		_renderTask = RenderTelemetryLoopAsync(_cts.Token);
		_pollTask = PollStatusLoopAsync(_cts.Token);
		return Task.CompletedTask;
	}

	protected override async Task OnParametersSetAsync()
	{
		if (_cts is null)
		{
			return;
		}

		if (string.Equals(_currentSimId, SimId, StringComparison.OrdinalIgnoreCase))
		{
			return;
		}

		_currentSimId = SimId;
		_error = null;

		// If we have cached UI state, show it immediately (useful when sim is paused).
		if (ViewCache.TryGet(SimId, out var state))
		{
			var snap = state.Snapshot();
			if (snap.ParameterEdits.Count > 0)
			{
				_parameterEdits.Clear();
				foreach (var kvp in snap.ParameterEdits)
				{
					_parameterEdits[kvp.Key] = kvp.Value;
				}
			}
			if (snap.LatestSnapshot is not null)
			{
				Volatile.Write(ref _latestSnapshot, snap.LatestSnapshot);
				_uiSnapshot = snap.LatestSnapshot;
				_tableSnapshot = snap.LatestSnapshot;
				_lastUiTick = snap.LatestSnapshot.Tick;
				_pressureSeries = snap.PressureSeries;
				_positionSeries = snap.PositionSeries;
				_flowSeries = snap.FlowSeries;
				_sortedSignals = snap.SortedSignals;
				await InvokeAsync(StateHasChanged);
			}
		}
		else if (Hub.TryGetLatestSnapshot(SimId, out var cachedHubSnapshot))
		{
			Volatile.Write(ref _latestSnapshot, cachedHubSnapshot);
			_uiSnapshot = cachedHubSnapshot;
			_tableSnapshot = cachedHubSnapshot;
			_lastUiTick = cachedHubSnapshot.Tick;
			await InvokeAsync(StateHasChanged);
		}

		// Reset UI state when switching sims.
		// Keep cached visuals, but reset local series buffers for fresh accumulation.
		_pressurePoints.Clear();
		_positionPoints.Clear();
		_flowPoints.Clear();

		try
		{
			_parameterDefinitions = await Api.GetParameterDefinitionsAsync(SimId, _cts.Token);
			var values = await Api.GetParameterValuesAsync(SimId, _cts.Token);

			// Merge server values into cached edits (but keep any user-entered drafts).
			var viewState = ViewCache.GetOrCreate(SimId);
			viewState.MergeParameterEditsFromValues(values);
			if (_parameterDefinitions is not null)
			{
				viewState.RemoveUnknownParameterEdits(_parameterDefinitions.Select(d => d.Name).ToArray());
			}

			_parameterEdits.Clear();
			foreach (var kvp in viewState.ParameterEditsSnapshot())
			{
				_parameterEdits[kvp.Key] = kvp.Value;
			}
		}
		catch (Exception ex)
		{
			_error = ex.Message;
		}

		try
		{
			await Hub.JoinSimulationAsync(SimId, _cts.Token);
		}
		catch (Exception ex)
		{
			_error = ex.Message;
		}
	}

	private void OnSnapshot(TelemetrySnapshot snapshot)
	{
		if (!string.Equals(snapshot.SimId, SimId, StringComparison.OrdinalIgnoreCase))
		{
			return;
		}
		Volatile.Write(ref _latestSnapshot, snapshot);
		ViewCache.GetOrCreate(snapshot.SimId).SetSnapshot(snapshot);
	}

	private async Task RenderTelemetryLoopAsync(CancellationToken cancellationToken)
	{
		using var timer = new PeriodicTimer(TimeSpan.FromMilliseconds(100)); // 10Hz UI refresh
		try
		{
			while (await timer.WaitForNextTickAsync(cancellationToken))
			{
				var snapshot = Volatile.Read(ref _latestSnapshot);
				if (snapshot is null)
				{
					continue;
				}

				if (snapshot.Tick == _lastUiTick)
				{
					continue;
				}

				_lastUiTick = snapshot.Tick;
				_uiSnapshot = snapshot;

				lock (_seriesLock)
				{
					var t = snapshot.TimeSeconds;
					Append(_pressurePoints, t, snapshot.Signals.GetValueOrDefault("DownstreamPressurePsi"));
					Append(_positionPoints, t, snapshot.Signals.GetValueOrDefault("ActuatorPosition"));
					Append(_flowPoints, t, snapshot.Signals.GetValueOrDefault("ValveFlowGpm"));

					_pressureSeries = _pressurePoints.ToArray();
					_positionSeries = _positionPoints.ToArray();
					_flowSeries = _flowPoints.ToArray();
				}

				var now = DateTimeOffset.UtcNow;
				if (now - _lastTableRefreshAt >= TimeSpan.FromMilliseconds(500))
				{
					_lastTableRefreshAt = now;
					_tableSnapshot = snapshot;
					_sortedSignals = snapshot.Signals
						.OrderBy(k => k.Key, StringComparer.OrdinalIgnoreCase)
						.ToArray();
				}

				// Persist last-rendered UI state so navigation back can instantly rehydrate.
				ViewCache.GetOrCreate(snapshot.SimId).SetRenderedState(
					snapshot,
					_pressureSeries,
					_positionSeries,
					_flowSeries,
					_sortedSignals);

				await InvokeAsync(StateHasChanged);
			}
		}
		catch (OperationCanceledException)
		{
			// normal shutdown
		}
	}

	private static void Append(List<LineChart.Point> series, double timeSeconds, double value)
	{
		series.Add(new LineChart.Point(timeSeconds, value));
		if (series.Count <= MaxPoints)
		{
			return;
		}

		var remove = series.Count - MaxPoints;
		series.RemoveRange(0, remove);
	}

	private async Task PollStatusLoopAsync(CancellationToken cancellationToken)
	{
		while (!cancellationToken.IsCancellationRequested)
		{
			try
			{
				var simId = _currentSimId;
				if (!string.IsNullOrWhiteSpace(simId))
				{
					_status = await Api.GetStatusAsync(simId, cancellationToken);
				}
				await InvokeAsync(StateHasChanged);
			}
			catch
			{
				// ignore transient errors while starting up/reconnecting
			}

			await Task.Delay(500, cancellationToken);
		}
	}

	private async Task Pause()
	{
		_error = null;
		try { await Api.PauseAsync(_currentSimId ?? SimId, _cts?.Token ?? default); } catch (Exception ex) { _error = ex.Message; }
	}

	private async Task Resume()
	{
		_error = null;
		try { await Api.ResumeAsync(_currentSimId ?? SimId, _cts?.Token ?? default); } catch (Exception ex) { _error = ex.Message; }
	}

	private async Task StepOnce()
	{
		_error = null;
		try { await Api.StepAsync(_currentSimId ?? SimId, 1, _cts?.Token ?? default); } catch (Exception ex) { _error = ex.Message; }
	}

	private void OnEditChanged(string name, ChangeEventArgs e)
	{
		if (e.Value is null)
		{
			return;
		}

		if (double.TryParse(e.Value.ToString(), out var parsed))
		{
			_parameterEdits[name] = parsed;
			ViewCache.GetOrCreate(_currentSimId ?? SimId).SetParameterEdit(name, parsed);
		}
	}

	private async Task ApplyParameter(string name)
	{
		_error = null;
		try
		{
			if (_parameterEdits.TryGetValue(name, out var v))
			{
				await Api.SetParameterAsync(_currentSimId ?? SimId, name, v, _cts?.Token ?? default);
			}
		}
		catch (Exception ex)
		{
			_error = ex.Message;
		}
	}

	public async ValueTask DisposeAsync()
	{
		Hub.SnapshotReceived -= OnSnapshot;
		try { await Hub.LeaveCurrentSimulationAsync().ConfigureAwait(false); } catch { /* ignore */ }
		var cts = Interlocked.Exchange(ref _cts, null);
		if (cts is not null)
		{
			try { cts.Cancel(); } catch { /* ignore */ }
			cts.Dispose();
		}
		if (_renderTask is not null)
		{
			try { await _renderTask.ConfigureAwait(false); } catch { /* ignore */ }
		}
		if (_pollTask is not null)
		{
			try { await _pollTask.ConfigureAwait(false); } catch { /* ignore */ }
		}
	}
}
